\documentclass{report}
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage[lmargin=2.5cm,rmargin=2.5cm,tmargin=2.5cm,bmargin=3.5cm]{geometry}
\usepackage[pdftex]{lscape}
\usepackage{wrapfig}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{ifthen}
\usepackage{bussproofs}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{url}
\usepackage{qtree}
\usepackage{sty/fitch}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% H A B I L I T A N D O   A B R E V I A Ç Ã O %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\EnableBpAbbreviations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C O M A N D O S   D E   S U B S T I T U I Ç Ã O %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\e}{\land}
\newcommand{\ou}{\lor}
\newcommand{\n}{\lnot}
\newcommand{\im}{\rightarrow}
\newcommand{\bi}{\leftrightarrow}
\newcommand{\cl}{\vdash}
\newcommand{\el}{\equiv}
\newcommand{\pred}[1]{\mathtt{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C O N F I G U R A Ç Õ E S  D O S   C Ó D I G O S %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{numbers=left, stepnumber=1, firstnumber=1,
numberstyle=\tiny, extendedchars=true, breaklines=true,frame=tb,
basicstyle=\footnotesize, stringstyle=\footnotesize, showstringspaces=false}

\renewcommand{\lstlistingname}{Código}
\renewcommand{\lstlistlistingname}{Lista de Códigos}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% C O N F I G U R A Ç Õ E S   D A   P Á G I N A %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\footskip=1cm \setcounter{tocdepth}{5} \setcounter{secnumdepth}{5}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% E S P A Ç A M E N T O   D U P L O %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\baselinestretch}{1.5}

\title{Prova por Resolução Utilizando Estratégia de Proposições Enquadradas em Paralelo Utilizando OpenMp}
\author{Diogo Cezar Teixeira Batista \\ Universidade Federal do Paraná}


\begin{document}

    \maketitle

    \tableofcontents
    \listoffigures
    \listoftables
    \lstlistoflistings


    \chapter{Introdução}

    A lógica, em um contexto geral, pretende representar um raciocínio válido. Essa validade depende de uma interpretação que é inserida em um determinado contexto. Por meio de axiomas (símbolos) e regras de inferência, consegue-se mapear algumas situações do mundo real para um contexto lógico, podendo assim, delegar explorações para um sistema automático.

    Para representar situações do mundo real, gera-se prováveis teoremas compostos pelas premissas (informações que se sabe sobre o fato) e pelas conclusões (informações que se deseja inferir).

    Por exemplo, pode-se descrever a seguinte situação:

    \begin{itemize}
        \item [premissas]
        \begin{enumerate}
            \item Sócrates estaria disposto a visitar Platão, se Platão estivesse disposto a visitá-lo;
            \item Platão não estaria disposto a visitar Sócrates, se Sócrates estivesse disposto a visitá-lo;
            \item Platão estaria disposto a visitar Sócrates, se Sócrates não estivesse disposto a visitá-lo;
        \end{enumerate}
        \item [conclusão]
        \begin{enumerate}
            \item pergunta-se: Sócrates está disposto a visitar Platão ou não?
        \end{enumerate}
    \end{itemize}

    Com tais informações, é possível mapear cada uma das sentenças para a lógica, gerando então um teorema. Assumindo que:

    \begin{itemize}
        \item Sócrates é representado por $S$;
        \item Platão é representado por $P$;
        \item a premissa 1 é representada por $P \im S$;
        \item a premissa 2 é representada por $S \im \n P$;
        \item a premissa 3 é representada por $\n S \im P$;
    \end{itemize}

    Então o teorema que representa tal situação é dado pela representação lógica no formato clausal da conclusão 1:

    \begin{equation}
        \label{socrates_platao}
        (P \im S), (S \im \n P), (\n S \im P) \cl S
    \end{equation}

    A conclusão ainda pode ser representada pela seguinte notação:

    \begin{equation}
        \label{socrates_platao1}
        P \im S \e S \im \n P \e \n S \im P \cl S
    \end{equation}

    Uma das vertentes da lógica, é a tentativa de se provar se um determinado teorema é ou não válido. Essa prova pode ser obtida de diferentes formas, uma delas é a busca axiomática, que visa encontrar a prova para determinado teorema por meio da manipulação de símbolos por regras de inferência; outra forma é a busca semântica, que a partir de transformações na fórmula original, mantém a equivalência preservando as propriedades do teorema original, reduzindo a fórmula e aplicando a prova em um teorema mais simples \cite{Enderton}.

    Pelas regras de adequação e completude, se um teorema for provado pelas regras da semântica diz-se que esse também pode ser provado pelas regras axiomáticas, assim garante-se que um teorema é valido. Nesse contexto o trabalho desenvolvido visa estabelecer a prova pelas regras semânticas.

    As Equações \ref{socrates_platao} e \ref{socrates_platao1} representam fórmulas no contexto da lógica proposicional, que consegue representar simples ações do mundo real. Representações mais complexas estão contidas na lógica de primeira ou segunda ordem, que estão fora do escopo desse trabalho.

    Existem algumas técnicas para se provar se um teorema é ou não válido, dentre elas estão:

    \begin{itemize}
        \item sistema dedutivo de Hilbert;
        \item resolução;
        \item tableau;
        \item sequentes;
    \end{itemize}

    Para o presente trabalho, propõe-se a utilização do método de prova por resolução, utilizando as técnicas de resolução linear e proposições enquadradas, que serão detalhadas no Capítulo \ref{referencial}.

    A grande dificuldade de realizar a prova por resolução de grandes teoremas (com centenas ou milhares de cláusulas) está na explosão combinatória que esse tipo de problema gera. Provar teoremas pode levar um tempo muito grande, ou até depender de recursos de hardware indisponíveis, o que acaba tornando o problema inviável para implementações sequenciais.

    Por mais rápidos que os processadores possam ser, estamos atingindo o limite físico da velocidade com que os processadores podem trabalhar. Problemas complexos, como a prova por resolução, demandam uma grande quantidade de processamento e dependem de uma solução eficiente. A programação paralela entra nesse contexto, com a idéia de manter vários processadores trabalhando paralelamente com partes menores de um problema maior \cite{1266729}.

    Dentre as maneiras de paralelismo estão:

    \begin{itemize}
        \item computadores inter-conectados por uma rede;
        \item processadores de múltiplos núcleos;
        \item computadores com $p$ processadores;
        \item placa gráfica \emph{Graphics Processing Unit} (GPU), aproveitando micro-processadores.
    \end{itemize}

    O presente trabalho busca explorar uma solução paralela utilizando a divisão de trabalho por \emph{threads} (componentes que agrupam um determinado trabalho a ser executado) executadas paralelamente em múltiplos micro-processadores. Para isso, foi utilizada uma \emph{Application Programming Interface} (API) chamada OpenMP, que se enquadra para aplicações de memória compartilhada e facilita a programação paralela. A interface não é uma linguagem de programação, mas sim, uma extensão da linguagem C/C++ ou FORTRAN. OpenMP possui diretivas que indicam como o trabalho será dividido entre \emph{threads} e a ordem de acesso aos dados compartilhados     \cite{1211440}, \cite{1370966}.

    O Capítulo \ref{referencial} detalha os conceitos teóricos da lógica proposicional, da prova por resolução e de algumas estratégias para resolução. O Capítulo \ref{implementacoes} descreve as implementações propostas para a resolução linear com literais enquadrados em paralelo utilizando OpenMP. No Capítulo \ref{resultados} estão os testes realizados, mostra-se os resultados para os experimentos de Colaboração entre Cláusulas e Divisão de Trabalho por Threads e ainda aborda uma discussão sobre esses resultados. Por fim o Capítulo \ref{conclusao} mostra as conclusões do trabalho e os trabalhos futuros.

    \chapter{Referencial Teórico}
    \label{referencial}

    Esse capítulo discute os conceitos teóricos da lógica proposicional, da prova por resolução e de algumas estratégias para resolução.

    \section{Lógica Proposicional}

    A lógica proposicional é um sistema no qual suas fórmulas representam proposições (valores verdadeiros ou falsos) interligadas por conectivos lógicos. Esse sistema é formado por \cite{ginsberg:1993}:

    \begin{itemize}
        \item linguagem: se refere ao modo como se escreve uma sentença;
        \item semântica: se refere ao estudo do significado;
        \item axiomática: se refere ao conjunto de premissas iniciais e das proposições que são derivadas desse conjunto.
    \end{itemize}

    \subsection{Linguagem}

    A linguagem proposicional é formada por símbolos que irão representar nossas sentenças, normalmente representadas por letras minúsculas do alfabeto, possívelmente indexadas \cite{ginsberg:1993}:

    São exemplos: $p, q, r, p_1, q_1, r_1 \ldots$

    \subsubsection{Conectivos}

    São os elementos que executam as operações com os símbolos proposicionais \cite{Enderton}.

    \begin{itemize}
        \item $\wedge$ - corresponde ao conectivo \emph{e} (conjunção);
        \item $\vee$ - corresponde ao conectivo \emph{ou} (disjunção);
        \item $\neg$ - corresponde ao conectivo \emph{não} (negação);
        \item $\rightarrow$ - corresponde ao conectivo de atribuição ou \emph{implica em} (implicação);
        \item $\leftrightarrow$ - corresponde ao conectivo \emph{se e somente se} ou \emph{bi-implicação} (dupla implicação);
    \end{itemize}

    \subsection{Fórmulas}

    Uma fórmula proposicional é formada por uma ou mais proposições, que podem estar ligadas por conectivos \cite{Enderton}.

    Por exemplo: $p \ou q$.

    \subsection{Semântica}

    O contexto semântico refere-se ao significado. Podemos atribuir uma interpretação para uma fórmula proposicional, que valora as proposições com verdadeiro ou falso \cite{Enderton}.

    As soluções possíveis para $\{p,q\}$ são:

    \begin{center}
        $I(p) = 0, I(q) = 0$ \\
        $I(p) = 1, I(q) = 1$ \\
        $I(p) = 1, I(q) = 0$ \\
        $I(p) = 0, I(q) = 1$ \\
    \end{center}

    \subsection{Axiomática}

    Propõe a manipulação da fórmulas por meio de regras axiomáticas e de inferência, a axiomática de Hilbert é um exemplo de manipulação axiomática \cite{Enderton}.

    \subsection{Forma Normal Conjuntiva}

    Segundo \cite{Enderton}, uma fórmula proposicional está em Forma Normal Conjuntiva (FNC) se está na seguinte forma:

    \begin{equation}
        \alpha_1 \e \alpha_2 \e ... \e \alpha_n
    \end{equation}

    onde, cada $\alpha_i$ é uma cláusula na seguinte forma:

    \begin{equation}
        \beta_1 \ou \beta_2 \ou ... \ou \beta_m
    \end{equation}

    onde, cada $\beta_i$ é um literal (uma proposição ou sua negação).

    Por exemplo: $p \e q \ou r \e s$.

    \subsubsection{Transformação em FNC}

    Para toda fórmula proposicional existe uma FNC equivalente \cite{Enderton}, \cite{ginsberg:1993}, que pode ser obtida por meio das seguintes regras de equivalência:

    \begin{enumerate}
    \item Eliminação das implicações\\
      $\alpha \im \beta \equiv \n \alpha \ou \beta$\\
      $\alpha \bi \beta \equiv (\n \alpha \ou \beta) \e (\alpha \ou \n \beta)$\\
      $\n(\alpha \bi \beta) \equiv (\alpha \ou \beta) \e (\n \alpha \ou \n \beta)$
    \item Distribuição da negação:\\
      $\n \n \alpha \equiv \alpha$\\
      $\n (\alpha \e \beta) \equiv \n \alpha \ou \n \beta$\\
      $\n (\alpha \ou \beta) \equiv \n \alpha \e \n \beta$

    \item Distribuição da disjunção:\\
      $\alpha \ou (\beta \e \gamma) \equiv (\alpha \ou \beta) \e (\alpha \ou \gamma)$
    \end{enumerate}

    O trabalho parte da premissa que as fórmulas de entrada já se encontram em FNC.

    \section{Resolução}

    Esse método parte de uma única regra de inferência \cite{ginsberg:1993}:

    \begin{equation}
      \frac{\alpha \ou \Phi  \quad \quad \n \alpha \ou \Psi}%
           {\Phi \ou  \Psi}\;R(\alpha)
    \end{equation}

    Se $\alpha \ou \Phi$ é verdadeiro, e $\n \alpha \ou \Psi$ também é verdadeiro, então ou $\Phi$ é verdadeiro ou $\Psi$ ou ambos, então podemos concluir $\Phi \ou  \Psi$. $R(\alpha)$ mostra qual o literal foi resolvido.

    Seja $p \ou q \e \n p \ou r$ uma fórmula em FNC, poderíamos resolve-las da seguinte forma:

    \begin{equation}
        \begin{nd}
            \hypo{h1}  {p \ou q}
            \hypo{h2}  {\n p \ou r}
            \have{}  {q \ou r}   \by{R($\alpha = p$)}{h1,h2}
        \end{nd}
    \end{equation}

    Seja $p \ou q \e \n p \ou q$ uma fórmula em FNC, poderíamos resolve-las da seguinte forma:

    \begin{equation}
        \begin{nd}
            \hypo{h1}  {p \ou q}
            \hypo{h2}  {\n p \ou q}
            \have{c1}  {q}   \by{R($\alpha = p$)}{h1,h2}
        \end{nd}
    \end{equation}

    É importante lembrar que ao se obter $q \ou q$ podemos simplificar somente para $q$. Mais detalhes estão explicados na Seção \ref{simplificacao}.

    Seja $p \ou \n p$ uma fórmula em FNC, poderíamos resolve-las da seguinte forma:

    \begin{equation}
        \begin{nd}
            \hypo{h1}  {p}
            \hypo{h2}  {\n p}
            \have{c1}  {\emptyset \textrm{~~ou~~} \bot} \by{R($\alpha = p$)}{h1,h2}
        \end{nd}
    \end{equation}

    E nesse ponto encontramos uma cláusula vazia, que representa uma contradição (\emph{false}) e é também o objetivo do método.

    \subsection{Refutação por Resolução}

     O princípio da resolução é uma regra de inferência que dá origem a uma técnica de demonstração por refutação para sentenças e inferências da lógica proposicional e da lógica de primeira ordem \cite{Enderton}.

     Seja um conjunto de cláusulas $\mathbb{C}$, provar $\alpha$ parte-se do princípio:

     \begin{itemize}
        \item Aplica-se a regra de resolução sobre o conjunto $\mathbb{C} \cup \n \alpha$ buscando encontrar uma contradição;
        \item Se uma contradição for gerada, pode-se dizer que $\n \alpha$ não é verdade, logo $\alpha$ é verdade, e prova o teorema;
        \item Se nenhuma contradição for gerada, nada se pode dizer sobre o teorema.
     \end{itemize}

     Para exemplificar a regra de Refutação por Resolução, vamos utilizar a seguinte fórmula:

     \begin{equation}
        p \ou q \e p \im r \e q \im r \cl r
     \end{equation}

     Nessa fórmula temos 3 premissas ($\{p \ou q\}$,$\{p \im r\}$,$\{q \im r\}$) e uma conclusão a ser provada ($\cl r$).

     O primeiro passo é chegar na forma normal conjuntiva (FNC) da fórmula, aplicando as regras de equivalências nas cláusulas necessárias:

     \begin{eqnarray}
        p \im r \equiv \n p \ou r \\
        q \im r \equiv \n q \ou r
     \end{eqnarray}

     Adiciona-se como uma quarta premissa a negação da conclusão a ser provada e inicia-se o método de resolução:

    \begin{equation}
        \begin{nd}
        \hypo{h1}  {p \ou q}     \by{primeira premissa}{}
        \hypo{h2}  {\n p \ou r}  \by{segunda premissa}{}
        \hypo{h3}  {\n q \ou r}  \by{terceira premissa}{}
        \open
        \hypo{h4}  {\n r}  \by{negação da conclusão}{}
        \have{c1}  {\n p}  \by{R($\alpha = r$)}{h4,h2}
        \have{c2}  {q}     \by{R($\alpha = \n p$)}{c1,h1}
        \have{c3}  {r}     \by{R($\alpha = q$)}{c2,h3}
        \have{c4}  {\bot}  \by{R($\alpha = r$)}{c3,h4}
        \close
        \have{c8}  {r}     \by{refutação}{}
        \end{nd}
    \end{equation}

    Dessa maneira consegue-se provar $r$.

    \subsection{Estratégias para Resolução}
    \label{estrategias}

    Ao se aplicar uma estratégia não restringida do método de resolução, a cada passo, encontra-se várias possibilidades de resolução. Resolvendo todos os passos possíveis garante-se que se houver uma cláusula vazia ela será encontrada, entretanto a explosão combinatória torna a implementação inviável. Algumas técnicas de resolução propõem recursos para diminuir o espaço de busca e aumentar a eficiência de um algoritmo de resolução \cite{resolu}, \cite{resolu2}.

    \subsubsection{Simplificação}
    \label{simplificacao}

    Durante a resolução das cláusulas, no instante da junção para formar uma cláusula resultante, é comum encontrar a ocorrência de literais repetidos, como por exemplo: $\{ p, \n q, \n w \}, \{ p, \n q, w \}$.

    Nesse caso pode-se conservar apenas uma ocorrência da proposição que poderia se repetir.

    \begin{equation}
        \begin{nd}
            \hypo{h1}  {p \ou \n q \ou \n w}
            \hypo{h2}  {p \ou \n q \ou w}
            \have{c1}  {p \ou \n q} \by{correto}{}
        \end{nd}
        \hspace{1.5cm}
        \begin{nd}
            \hypo{h1}  {p \ou \n q \ou \n w}
            \hypo{h2}  {p \ou \n q \ou w}
            \have{c1}  {p \ou \n q \ou p \ou \n q} \by{errado}{}
        \end{nd}
    \end{equation}

    \subsubsection{Remoção de Tautologias}
    \label{tautologia}

    Uma tautologia é a ocorrência de um literal e sua negação na mesma cláusula, esse tipo de informação de nada adianta na resolução.

    Sendo uma cláusula $\{p, \n p, q\}$, supondo que $q$ já foi resolvido, então para encontrar a cláusula vazia é necessário que haja no conjunto de cláusulas $\n p$ e $p$, se elas já estão no conjunto de cláusulas então não é necessário utilizar essa cláusula para efetuar nenhum cálculo, logo essa cláusula pode ser removida.

    \subsubsection{Remoção de Cláusulas com Literal Puro}

    Um literal é dito puro, se não existe no conjunto de cláusulas nenhuma ocorrência de seu complementar. Se não há seu complementar, essa cláusula nunca ficará vazia e não ajudará na busca.

    \subsubsection{Resolução Linear}

    A estratégia de resolução linear propõe uma ordem para a resolução das cláusulas. Partindo de uma cláusula centro $c_0$ se obtém na lista de cláusulas, 0, 1 ou mais  resolventes, que são origem a uma nova lista $r_0$. Um membro gerado dessa lista, se torna a nova cláusula centro, e repete-se o procedimento até que a cláusula vazia seja encontrada.

    Por exemplo, seja um conjunto de cláusulas: $\mathbb{C} = \{q \ou p, \n p \ou r, \n r \ou \n p, \n q\}$

    \begin{equation}
        \label{eq:linear}
        \begin{nd}
            \hypo{h1}  {q \ou p}
            \hypo{h2}  {\n p \ou r}
            \hypo{h3}  {\n r \ou \n p}
            \hypo{h4}  {\n q}
            \open
            \hypo{h5}  {p}      \by{R($\alpha = q$)}{h1,h4}
            \hypo{h6}  {r}      \by{R($\alpha = p$)}{h5,h2}
            \hypo{h7}  {\n p}   \by{R($\alpha = r$)}{h6,h3}
            \have{c1}  {\bot}   \by{R($\alpha = \n p$)}{h7,h5}
        \end{nd}
    \end{equation}

    Como visto na Seção \ref{tautologia}, quando uma tautologia é encontrada, continuar a prova dessa cláusula não chegará na cláusula vazia, então esse método só se torna completo se alguma técnica de \emph{backtrack} for utilizada.

    Por exemplo, seja um conjunto de cláusulas:

    \begin{equation}
        \begin{nd}
        \hypo{h1}  {s \ou r}
        \hypo{h2}  {\n s \ou w}
        \hypo{h3}  {\n r \ou \n w}
        \hypo{h4}  {\n p \ou t}
        \hypo{h5}  {\n t \ou q}
        \hypo{h6}  {p}
        \hypo{h7}  {\n q}
        \open
        \hypo{h8}  {r \ou w}    \by{R($\alpha = s$)}{h1,h2}
        \hypo{h9}  {w \ou \n w} \by{R($\alpha = w$)}{h8,h3}
        \have{c1}  {\emph{tautologia}}
        \end{nd}
    \end{equation}

    Nesse caso é necessário recuar e verificar se existem outras possibilidades. No exemplo, ao se iniciar com as cláusulas $(1,2)$ chegou-se a uma situação sem saída, igualmente se a resolução iniciar com as cláusulas $(1,3)$ ou $(2,3)$. Ao resolver a cláusula $4$ conseguimos uma situação que leva a cláusula vazia.

    Se uma tautologia for eleita como a cláusula a ser resolvida, o \emph{backtrack} deve ser acionado, pois não é possível chegar a uma cláusula vazia partindo de uma tautologia.

    \subsubsection{Estratégia dos Literais Enquadrados}

    A estratégia de resolução linear com literais enquadrados (ou \emph{framed}) propõe que os literais resolvidos não sejam removidos das cláusulas resultantes, mas marcados como enquadrados. A estratégia define duas regras que permitem encontrar a cláusula vazia, são elas:

    \begin{itemize}
        \item resolução: se o último literal da cláusula for complementar de um literal $p$, ou seja ($\n p$) enquadrado, então pode-se remover esse literal da lista;
        \item eliminação: quando se obtém uma cláusula com literal enquadrado não seguido de nenhum literal "não enquadrado"{} esse também pode ser removido da lista de literais.
    \end{itemize}

    Utilizando o exemplo da resolução \ref{eq:linear}, seja um conjunto de cláusulas $\mathbb{C} = \{q \ou p, \n p \ou r, \n r \ou \n p, \n q\}$, resolve-se aplicando a técnica de resolução linear com literal enquadrado:

    \begin{equation}
        \begin{nd}
            \hypo{h1}  {q \ou p}
            \hypo{h2}  {\n p \ou r}
            \hypo{h3}  {\n r \ou \n p}
            \hypo{h4}  {\n q}
            \open
            \hypo{h5}  {q \ou [p] \ou r}                \by{R($\alpha = p$)}{h1,h4}
            \hypo{h6}  {q \ou [p] \ou [r] \ou \neg p}   \by{R($\alpha = r$)}{h5,h2}
            \hypo{h8}  {q \ou [p] \ou [r]}              \by{\emph{resolução}}{}
            \hypo{h9}  {q}                              \by{\emph{eliminação}}{}
            \have{c1}  {\bot}                           \by{R($\alpha = q$)}{h9,h4}
        \end{nd}
    \end{equation}

    \chapter{Implementações}
    \label{implementacoes}

    Nesse capítulo são mostradas as implementações propostas para a resolução linear com literais enquadrados em paralelo utilizando OpenMP. Uma visão geral da estrutura da solução está na Seção \ref{estrutura_solucao}, a primeira abordagem parcial contendo um método de colaboração entre cláusulas está na Seção \ref{colab} e uma segunda abordagem contendo uma solução completa com a divisão do trabalho por \emph{threads} está na Seção \ref{thread}.

    \section{Estrutura da Solução}
    \label{estrutura_solucao}

    A estratégia adotada para a implementação foi a utilização de estruturas de listas encadeadas que representam as cláusulas. Cada cláusula possui informações que formam uma sêxtupla $C<I,L,F,T,P,N>$:

    \begin{itemize}
        \item[$I$] é a identificação da cláusula, na estrutura representada por um tipo de dado \emph{int};
        \item[$L$] é o rótulo (\emph{label}) da cláusula, armazena uma \emph{string} que representa a junção de suas proposições, por exemplo ($p \ou q \ou \n r$). Na estrutura representada por um tipo de dado \emph{char};
        \item[$F$] é uma dupla $F<A,B>$ que guarda informações sobre quais foram as suas cláusulas pai, $A$ e $B$ são do tipo \emph{int};
        \item[$T$] é a marcação binária de uma tautologia, representada na estrutura por um tipo de dado \emph{int};
        \item[$P$] é uma quádrupla $P<L,N,F,N_e>$:
        \begin{itemize}
            \item[$L$] é o rótulo da proposição. Armazena uma string que representa um único literal, por exemplo $p$. Representado por um tipo de dado \emph{char};
            \item[$N$] é a marcação binária de negativo da proposição. Na estrutura representado pelo tipo de dado \emph{int};
            \item[$F$] é a marcação binária de enquadrado (\emph{framed}) da proposição. Na estrutura também representado por \emph{int};
            \item[$N_e$] é um ponteiro para a próxima proposição;
        \end{itemize}
        Cada cláusula armazena um ponteiro para uma estrutura $P$ que guarda suas proposições;
        \item[$N$] armazena um ponteiro para a próxima cláusula.
    \end{itemize}

    Essas estruturas são preenchidas por um arquivo de entrada que aceita dois tipos de formatações, uma delas criada de forma empírica e outra utilizada para testar as fórmulas maiores que segue o padrão \emph{DIMACS Challenge}. Seja uma FNC: $p \ou q \e \n p \e \n q$, os arquivos de entrada aceitos são:

    \texttt{\lstinputlisting[language=C, label=cod:input_1,
    caption={Exemplo de arquivo de entrada}]{codes/input_1.txt}}


    \texttt{\lstinputlisting[language=C, label=cod:input_2,
    caption={Exemplo de arquivo de entrada no formato DIMACS Challenge}]{codes/input_2.txt}}

    A saída do programa assume dois tipos:

    \begin{itemize}
        \item resumido: apresenta uma lista de informações relevantes como: nome da fórmula, binário que mostra se achou ou não a cláusula vazia, a identificação da cláusula em que a cláusula vazia foi encontrada, o número de threads que participaram da busca, o número de \emph{backtracks} efetuados, qual foi a thread que achou a cláusula vazia e o tempo em segundos de execução;
        \item extendido: mostra o conjunto completo de cláusulas geradas até encontrar a cláusula vazia, bem como o tempo de execução em segundos.
    \end{itemize}

    Para aumentar a flexibilidade dos testes, o programa recebe 2 parâmetros obrigatórios que indicam: a fórmula de entrada a ser processada e o número de \emph{threads} que irão processar, respectivamente. Com isso conseguiu-se a criação de \emph{shell scripts} para automatizar a bateria de testes.

    Dentre as estratégias de resolução descritas na Seção \ref{estrategias} foram implementadas: simplificação, resolução linear, e estratégia dos literais enquadrados. Não foi implementado um mecanismo para remoção de tautologias, mas elas precisam ser identificadas, pois esse é um dos mecanismos que aciona o recurso de \emph{backtrack}.

    \subsection{Idéia Geral}
    \label{ideia_geral}

    A busca de uma cláusula vazia por resolução linear, gera uma estrutura em árvore. Cada cláusula pode ser combinada com $0$, $1$ ou $n$ outras cláusulas do conjunto.

    Sejam as cláusulas:
    \begin{equation}
        \begin{nd}
            \hypo{h1}  {p \ou r}
            \hypo{h2}  {\n s \ou q}
            \hypo{h3}  {\n p \ou s}
            \hypo{h4}  {\n q}
            \hypo{h5}  {\n r}
        \end{nd}
    \end{equation}

    Ao escolher a cláusula 1 ($p \ou r$) achamos um resolvente em 3 ($\n p \ou s$) ou em 5 ($\n r$). Mas também poderíamos iniciar a busca pela cláusula 2 ($\n s \ou q$) achando resonvente em 3 ($\n p \ou s$) ou em 4 ($\n q$), e assim sucessivamente. Dessa forma pode-se encontrar uma ramificação diferente para cada cláusula inicial selecionada.

    \begin{figure}[!htb]
        \centering
        \caption{Estrutura em árvore de cláusulas candidatas}
        \includegraphics[width=5cm]{images/tree_1.jpg}
        \label{fig:tree_1}
    \end{figure}

    A Figura \ref{fig:tree_1} representa a estrutura em árvore das cláusulas candidatas para resolverem $p \ou r$ e $\n s \ou q$. A resolução linear propõe uma busca somente por um dos ramos dessa árvore, até que se encontre a cláusula vazia, se a cláusula vazia não for encontrada em todas as sub-ramificações, então deve-se iniciar a busca no próximo ramo da árvore. Em uma implementação sequencial a busca em profundidade ocasiona muito trabalho, caso se tenha que retornar aos primeiros filhos da árvore de busca.

    A idéia essencial para as implementações foi a divisão das ramificações por \emph{threds}. Destinou-se $p$ \emph{threads} para resolver a sequência de cláusulas.

    Em uma abordagem em PRAM \cite{520759}, \cite{1608962} poderíamos obter os seguintes pseudo-códigos:

    \texttt{\lstinputlisting[language=C, label=cod:pram1,
    caption={Abordagem PRAM para resolução linear com adição de threads}]{codes/pram1.txt}}

    Em um modelo conceitual, a solução mostrada no Código \ref{cod:pram1} propõe a adição de threads a medida em que novas cláusulas são adicionadas no conjunto. Para cada nova cláusula se aloca um novo \emph{thread}. No pseudo-código, as cláusulas estão alocadas na variável $c$. A Linha 1, garante a execução do código enquanto uma cláusula vazia não for encontrada no banco de cláusulas. Para processadores que vão de $1$ a $n$ (com $n$ sendo o número de cláusulas iniciais), se executa as seguintes instruções: \texttt{c := resolve(c[j], search\_denied\_clauses(c[j]));} que adiciona ao banco de cláusulas todas as soluções de $c[j]$ resolvidas com um outro conjunto que retorna os resolventes de $c[j]$. O próximo passo é marcar quais foram as cláusulas resolvidas, que não serão selecionadas em uma próxima iteração. E por fim, se incrementa o número de processadores que irão executar no próximo passo do algoritmo.

    A criação de \emph{threads} nesse modelo também se dará em proporções de explosão combinatória, entretanto uma única \emph{thread} será responsável por executar a criação dos filhos da cláusula tratada por ela.

    Uma segunda abordagem mais refinada e adaptada para uma implementação real propõe:

    \texttt{\lstinputlisting[language=C, label=cod:pram2,
    caption={Abordagem PRAM para resolução linear}]{codes/pram2.txt}}

    Na abordagem do Código \ref{cod:pram2} apresenta-se algo bastante semelhante com o Código \ref{cod:pram1}, entretanto nessa abordagem se define um $j$ \emph{threads} para tratarem de $n$ cláusulas. Cada \emph{thread} fica responsável por resolver uma ramificação gerada a partir da cláusula de origem que lhe foi definida. Nesse caso não há adição de novos \emph{threads}, o que possibilita uma adaptação do modelo para uma implementação real.

    Em uma implementação real não teríamos disponíveis um número de \emph{threads} igual ao número de cláusulas. Para a implementação, criou-se um mecanismo para distribuir as \emph{threads} a medida que as ramificações forem resolvidas e em paralelo propõe-se a criação de uma lista anexa a lista de cláusulas, que possui um repositório de elementos a serem resolvidos (essa estrutura corresponde a marcação das cláusulas resolvidas). Inicialmente a lista de pendências inicia com uma cópia das cláusulas iniciais, e segue as regras:

    \begin{enumerate}
        \item Ao se resolver uma cláusula, ela deve ser removida da lista de pendências;
        \item Ao ser gerada uma nova cláusula, ela deve ser adicionada na lista de pendências;
    \end{enumerate}

    Dessa forma se garante que essa lista armazenará todas as cláusulas que ainda precisam ser resolvidas. Ao se sacar o último elemento inserido nessa lista, realiza-se uma busca em profundidade pela árvore. Para iniciar uma busca em largura, basta selecionar o primeiro elemento inserido na lista, entretanto a busca em largura mostra-se ineficiente para o problema proposto.

    O método de \emph{backtrack} é garantido pela resolução de todos os elementos da lista de pendências. Quando a próxima cláusula dessa lista a ser resolvida for uma tautologia (Seção \ref{tautologia}) então, ignora-se essa cláusula e parte-se para a resolução da próxima até que a lista esteja vazia ou contenha apenas tautologias.

     A lista de pendências indica para toda a árvore quais são as cláusulas a serem resolvidas, entretanto compartilha-lha entre as \emph{threads} gera um custo de sincronização que inviabiliza a implementação, por isso gerou-se duas abordagens de implementação: Colaboração entre Cláusulas e Divisão de Trabalho por \emph{Threads} que serão explicadas nas Seções \ref{colab} e \ref{thread} respectivamente.

    \section{Colaboração entre as Cláusulas}
    \label{colab}

    Nessa abordagem, eliminou-se o recurso de lista de pendências, o que ocasionou uma implementação incompleta. A idéia inicial foi analisar o comportamento de uma possível colaboração entre as cláusulas resolvidas de um \emph{thread} com as cláusulas resolvidas de outro. Cada \emph{thread} fica responsável por sacar um ramo a ser resolvido, e todas as cláusulas resolvidas são compartilhadas entre as \emph{threads}. Uma \emph{thread} não se preocupa caso não ache uma solução, sua participação é a geração das cláusulas. Cada uma delas, também não se preocupa em explorar todas as possibilidades de resolução de uma cláusula, mas assume que a primeira já é suficiente. Esse procedimento torna a abordagem incompleta, entretanto pendurar todas as cláusulas geradas, inviabiliza a colaboração entre as cláusulas.

    Supondo que o um \emph{thread} $t_1$ precise de uma cláusula $\n r$ para resolver a cláusula atual que é $r$, linearmente $\n r$ seria encontrado apenas nas próximas cláusulas ou até mesmo não encontrado nessa ramificação, entretanto a \emph{thread} $t_2$ resolveu $p \ou r$ e achou $r$ e consequentemente compartilhou na lista global de cláusulas, então a \emph{thread} $t_1$ encontrará a cláusula vazia em um tempo consideravelmente menor.

    Com essa abordagem foi necessário adotar um sistema de sincronização no momento de se inserir uma nova cláusula resolvida no banco de cláusulas, o sistema adotado foi a utilização de um semáforo com a diretivas do OpenMP \texttt{omp\_func\_lock}, que possibilitam a gerência de sincronismo.

    Essa característica de colaboração não pode ser aplicada em uma estrutura completa, pois cada resolução gera inúmeras cláusulas a serem sincronizadas com o banco de cláusulas global, o que gera um alto custo de sincronização e alocação de espaço em memória.

    \section{Divisão de Trabalho por \emph{Threads}}
    \label{thread}

    Nessa abordagem implementou-se o recurso de lista de pendências, garantindo uma implementação completa. Cada \emph{thread} possui uma cópia da lista de cláusulas inicial (lista privada) e uma lista de pendências própria. Dessa forma eliminou-se qualquer tipo de colaboração entre as \emph{threads}, entretanto não há custo de sincronização, cada \emph{thread} pode trabalhar de forma independente, e é responsável por resolver apenas a ramificação inicial que lhe foi atribuída, caso essa ramificação não encontre uma cláusula vazia, então uma nova ramificação lhe é designada.

     Nessa implementação, apenas um ponto necessita de sincronismo, é no momento de comunicar aos outros \emph{threads} que a cláusula vazia foi encontrada. Como isso encerra o processamento, as demais \emph{threads} também irão encerrar o processamento. A mesma estratégia do OpenMP \texttt{omp\_func\_lock} foi utilizada para garantir o sincronismo.

    \chapter{Resultados}
    \label{resultados}

    Esse capítulo descreve os testes realizados, mostra os resultados para os experimentos de Colaboração entre Cláusulas e Divisão de Trabalho por Threads e aborda uma discussão dos resultados encontrados, que estão respectivamente nas Seções \ref{testes}, \ref{result:colab}, \ref{result:thread} e \ref{discussao}

    \section{Descrição dos Testes}
    \label{testes}

    Para a realização dos testes utilizou-se fórmulas proposicionais não satisfatíveis. A busca por uma prova parte de um sistema refutacional, uma forma não satisfatível contempla essa condição. As fórmulas testadas foram retiradas do \emph{DIMACS Sat Benchmarks}, as selecionadas estão presentes na Tabela \ref{tab:formulas}.

    \begin{table}[!htb]
    \caption{Fórmulas testadas}
    \label{tab:formulas}
    \footnotesize{
        \begin{center}
            \begin{tabular}{|l|l|l|l|l|}
            \hline
            Nome & \multicolumn{1}{c|}{Tipo} & \multicolumn{1}{c|}{Literais} & \multicolumn{1}{c|}{Cláusulas} & \multicolumn{1}{c|}{Satisfatível?} \\
            \hline
            aim-50-1\_6-no-1 & \multicolumn{1}{c|}{aim} & \multicolumn{1}{c|}{50} & \multicolumn{1}{c|}{80} & \multicolumn{1}{c|}{Não} \\
            \hline
            aim-50-1\_6-no-3 & \multicolumn{1}{c|}{aim} & \multicolumn{1}{c|}{50} & \multicolumn{1}{c|}{80} & \multicolumn{1}{c|}{Não} \\
            \hline
            aim-50-1\_6-no-4 & \multicolumn{1}{c|}{aim} & \multicolumn{1}{c|}{50} & \multicolumn{1}{c|}{80} & \multicolumn{1}{c|}{Não} \\
            \hline
            dubois25 & \multicolumn{1}{c|}{dub} & \multicolumn{1}{c|}{75} & \multicolumn{1}{c|}{200} & \multicolumn{1}{c|}{Não} \\
            \hline
            dubois50 & \multicolumn{1}{c|}{dub} & \multicolumn{1}{c|}{150} & \multicolumn{1}{c|}{400} & \multicolumn{1}{c|}{Não} \\
            \hline
            dubois100 & \multicolumn{1}{c|}{dub} & \multicolumn{1}{c|}{300} & \multicolumn{1}{c|}{800} & \multicolumn{1}{c|}{Não} \\
            \hline
            hole6 & \multicolumn{1}{c|}{hole} & \multicolumn{1}{c|}{42} & \multicolumn{1}{c|}{133} & \multicolumn{1}{c|}{Não} \\
            \hline
            hole7 & \multicolumn{1}{c|}{hole} & \multicolumn{1}{c|}{56} & \multicolumn{1}{c|}{204} & \multicolumn{1}{c|}{Não} \\
            \hline
            \end{tabular}
        \end{center}
    }
    \end{table}

    Na Tabela \ref{tab:formulas} estão informações referentes ao nome da cláusula, seu tipo, a quantidade de literais, a quantidade de cláusulas e se é ou não satisfatível.

    Formulas do mesmo tipo significam que foram geradas da mesma forma, no qual:

    \begin{itemize}
        \item \emph{aim}: de Eiji Miyano $<$miyano@csce.kyushu-u.ac.jp$>$, geradas automaticamente;
        \item \emph{dub}: de Olivier Dubois $<$dubois@laforia.ibp.fr$>$, geradas automaticamente;
        \item \emph{hole}: de John Hooker $<$jh38+@andrew.cmu.edu$>$, problema do buraco de pombo. O problema pergunta se é possível colocar $n+1$ pombos em $n$ buracos sem ter dois pombos no mesmo buraco.
    \end{itemize}

    Os testes foram realizados na máquina \emph{Alt} que se encontra no Departamento de Informática da UFPR. Sua configuração é composta por 8 núcleos de processamento Intel Xeon E5345 de 2.33GHz e 7GB de memória RAM.

    No teste de Colaboração entre Cláusulas, as fórmulas da Tabela \ref{tab:formulas} foram testadas cem vezes, com isso calculou-se a média de tempo e o desvio padrão para a população gerada. Cada fórmula foi testada para 2, 4, 8 e 16 \emph{threads}. No teste de Divisão de Trabalho por \emph{Threads}, cada fórmula foi testada apenas dez vezes, pois algumas fórmulas demoraram alguns minutos para chegar ao resultado, o que impossibilitou um teste com mais repetições. Para essa população também foi gerado a média do tempo e o desvio padrão. Para essa abordagem utilizou-se testes com 1, 2, 4, 8, 16, 32 e 64 \emph{threads}. Nos testes realizados a unidade de medida de tempo adotada foi segundos.

    \newpage

    \section{Resultados para Colaboração entre Cláusulas}
    \label{result:colab}

    Para garantir que o sistema chegasse a um resultado em um tempo considerável, pelo método ser incompleto, se estabeleceu a quantidade máxima de 3500 cláusulas resolvidas, caso não se ache a solução até esse limite, então nada se pode dizer sobre o teorema, mas caso a cláusula vazia seja encontrada, então o teorema é provado.

    A Tabela \ref{tab:colab} mostra os resultados obtidos para o teste de Colaboração entre Cláusulas:

    \begin{table}[!htb]
    \caption{Resultados para Colaboração entre Cláusulas para 2, 4, 8 e 16 \emph{threads}}
    \label{tab:colab}
    \small{
        \begin{center}
            \begin{tabular}{|l|c|c|c|c|}
            \hline
             & \multicolumn{4}{c|}{\emph{threads}} \\
            \hline
            nome & 2 & 4 & 8 & 16 \\
            \hline
             & 617-1628 (97\%) & 630-3306 (43\%) & 1400-3479 (39\%) & 1893-3438 (21\%) \\
            aim-50-1\_6-no-1 & 0,119s & 1,978s & 2,791s & 2,831s \\
             & 0,071 & 1,55 & 1,447 & 1,446 \\
            \hline
             & 934-1149 (86\%) & 406-3047 (80\%) & 1286-3485 (34\%) & 1249-3465 (41\%) \\
            aim-50-1\_6-no-3 & 0,221s & 0,402s & 2,195s & 2,388s \\
             & 0,037 & 0,634 & 1,748 & 1,52 \\
            \hline
             & 969-2068 (95\%) & 802-3458 (93\%) & 620-3492 (56\%) & 1385-3295 (41\%) \\
            aim-50-1\_6-no-4 & 0,610s & 1,469s & 1,699s & 2,391s \\
             & 0,257 & 1,095 & 1,5 & 1,143 \\
            \hline
             & 1136-1384 (89\%) & 1616-2566 (69\%) & 1420-3303(19\%) & 1977-3360 (8\%) \\
            dubois25 & 0,672s & 3,345s & 4,548s & 6,234s \\
             & 0,169 & 1,274 & 2,456 & 2,75 \\
            \hline
            dubois50 & - & - & - & - \\
            \hline
            dubois100 & - & - & - & - \\
            \hline
             & 156-302 (98\%) & 216-441 (91\%) & 236-783 (95\%) & 591-949 (87\%) \\
            hole6 & 0,031s & 0,042s & 0,981s & 1,041s \\
             & 0,001 & 0,621 & 0,168 &  \\
            \hline
             & 244-476 (89\%) & 239-518 (78\%) & 417-936 (81\%) & 722-1354 (21\%) \\
            hole7 & 0,032s & 0,077s & 0,712s & 0,987s \\
             & 0,001 & 0,141 & 0,787 & 1,144 \\
            \hline
            \end{tabular}
        \end{center}
    }
    \end{table}

    A Tabela \ref{tab:colab} mostra as fórmulas testadas e para cada uma delas os resultados obtidos para a execução com 2, 4, 8 e 16 \emph{threads} respectivamente. Cada resultado é composto por 3 linhas, a primeira mostra o intervalo de cláusulas necessárias para se obter a cláusula vazia. Entre parênteses estão as porcentagens das fórmulas que conseguiram encontrar a cláusula vazia. A segunda linha mostra a média de execução do algoritmo e a terceira mostra o desvio padrão da população analisada.

    Testes com 1 \emph{thread} foram desconsiderados, pois pela implementação ser incompleta, execução com 1 \emph{threads} pode não chegar a um resultado com o limite imposto.

    As fórmulas \emph{dubois50} e \emph{dubois100} não encontraram uma cláusula vazia nos testes realizados.

    \section{Resultados para Divisão de Trabalho por \emph{Threads}}
    \label{result:thread}

    As Tabelas \ref{tab:threads1} e \ref{tab:threads2} mostram os resultados para o teste de Divisão de Trabalho por \emph{Threads}.

    \begin{table}[!htb]
    \caption{Resultados para Divisão de Trabalho com 1, 2, 4 e 8 \emph{threads}}
    \label{tab:threads1}
    \footnotesize{
        \begin{center}
            \begin{tabular}{|l|c|c|c|c|}
            \hline
             & \multicolumn{4}{c|}{\emph{threads}} \\
            \hline
            nome & 1 & 2 & 4 & 8 \\
            \hline
             & 3548  & 2047 - 2 & 1631 - 4 & 990 - 8 \\
            aim-50-1\_6-no-1 & 200,121s & 30,578s & 55,773s & 61s \\
             & 0,322 & 1,325 & 4,906 & 7,446 \\
            \hline
             & 4627 & 3056 - 2 & 1200 - 3 & 1200 - 3 \\
            aim-50-1\_6-no-3 & 171,875s & 37,757s & 23,234s & 77,82s \\
             & 3,021 & 3,33 & 3,90 & 11,316 \\
            \hline
             & 2487 & 1927 - 2 & 1927 - 2 & 845 - 7 \\
            aim-50-1\_6-no-4 & 312,121s & 22,468s & 53,328s & 30,687s \\
             & 0,321 & 0,441 & 1,445 & 6,529 \\
            \hline
             & 234 & 234 - 2 & {234, 238, 243, 252} - {1, 2, 3, 4} & {234, 243, 252} - {1,3,4} \\
            dubois25 & 0,001s & 0,062s & 0,156s & 0,39s \\
             & 0,001 & 0,019 & 0,06 & 0,118 \\
            \hline
             & 434 & 434 - 2 & {452, 438, 434} - {3, 4, 1} & {434, 438} - {1,4} \\
            dubois50 & 0,845s & 0,125s & 0,375s & 0,945s \\
             & 0,0124 & 0,019 & 0,062 & 0,241 \\
            \hline
             & 834 & 834 - 1 & {843, 852, 834} - {1, 2, 3} & {834, 838, 843, 865} - {1, 2, 3, 5} \\
            dubois100 & 0,125s & 0,226s & 0,804s & 2,054s \\
             & 0,002 & 0,032 & 0,158 & 0,255 \\
            \hline
             & 979 & 980 - 2 & {980, 982, 979} - {1, 3, 4} & {980, 984, 979} - {1,6,4} \\
            hole6 & 0,875s & 1,601s & 3,992s & 9,203s \\
             & 0,045 & 0,098 & 0,208 & 0,460 \\
            \hline
             & 1582 & {1583, 1582} - {1, 2} & {1584, 1582, 1583} - {1, 2, 3} & {1583, 1587, 1584} - {2, 3, 6} \\
            hole7 & 2,375s & 3,289s & 7,773s & 18,64s \\
             & 0,012 & 0,166 & 0,242 & 0,395 \\
            \hline
            \end{tabular}

        \end{center}
    }
    \end{table}

    \newpage

    \begin{table}[!htb]
    \caption{Resultados para Divisão de Trabalho com 16, 32 e 64 \emph{threads}}
    \label{tab:threads2}
    \footnotesize{
        \begin{center}
            \begin{tabular}{|l|c|c|c|}
            \hline
             & \multicolumn{3}{c|}{\emph{threads}} \\
            \hline
            nome & 16 & 32 & 64 \\
            \hline
             & 990 - 8 & 389 - 17 & 378 - 62 \\
            aim-50-1\_6-no-1 & 127,429s & 35,187s & 46,851s \\
             & 17,8 & 0,4 & 3,675 \\
            \hline
             & 700 - 10 & {700, 716} - {10, 26} & 247 - 58 \\
            aim-50-1\_6-no-3 & 57,914s & 103,476s & 24,296s \\
             & 9,024 & 28,51 & 0,549 \\
            \hline
             & 692 - 14 & 692 - 14 & 413 - 64 \\
            aim-50-1\_6-no-4 & 50,921s & 104,679s & 52,539 \\
             & 0,568 & 16,46 & 8,060 \\
            \hline
             & {264, 234, 265, 238} - {1,12, 13, 16} & {264, 238, 234, 265} - {1, 4, 9, 20} & {234, 252, 265, 238} - {1, 3, 4, 37} \\
            dubois25 & 0,851s & 1,828s & 3,351s \\
             & 0,193 & 0,341 & 0,978 \\
            \hline
             & {452, 434, 464, 452} - {3, 1, 12, 3} & {465, 452, 465, 443} - {1, 3, 9,} & {438, 434, 464, 465} - {4, 1, 12, 21} \\
            dubois50 & 1,757s & 3,773s & 8,429s \\
             & 0,347 & 0,772 & 1,017 \\
            \hline
             & {834, 864, 865} - {9, 12, 4}  & {834, 864, 865} - {1, 28, 32} & {864, 865, 834} - {1, 17, 48} \\
            dubois100 & 4,312s & 9,375s & 16,648s \\
             & 0,63 & 1,018 & 1,575 \\
            \hline
             & {1019, 979, 973} - {1, 5, 7} & {1019, 931} - {7, 3} & 1019 - 7 \\
            hole6 & 24,539s & 51,539s & 105,148s \\
             & 3,107 & 4,799 & 16,298 \\
            \hline
             & {1588, 1586, 1583} - {2, 5, 7} & {1588, 1583, 1587} - {2, 6, 7} & {1558, 1586} - {7, 5} \\
            hole7 & 43,71s & 129,656s & 273,929s \\
             & 15,364 & 27,591 & 59,808 \\
            \hline
            \end{tabular}
        \end{center}
    }
    \end{table}

    As Tabelas \ref{tab:threads1} e \ref{tab:threads2} contém para cada fórmula, informações correspondentes ao número de \emph{threads} executados. Em cada célula dos resultados encontra-se: o conjunto de 1 ou mais cláusulas e as \emph{threads} em que foram encontradas, a segunda linha mostra o tempo gasto para a execução, e a terceira linha mostra o desvio padrão.

    \section{Discussão dos Resultados}
    \label{discussao}

    Os resultados obtidos em geral não apresentaram um \emph{speedup} maior, a medida em que o número de \emph{threads} aumenta. Na primeira abordagem (Colaboração entre Cláusulas), isso acontece pela quantidade de sincronização necessária para garantir o compartilhamento entre as cláusulas, bem como a dependência de uma ordem não conhecida para a obtenção da cláusula vazia, e ainda há o tempo desperdiçado com a resolução de ramificações que não vão gerar a cláusula vazia. Na segunda abordagem (Divisão de Trabalho por \emph{Threads}) como cada ramificação é resolvida por uma \emph{thread} de forma independente, para alguns casos, consegui-se um tempo menor a medida em que threads são inseridas.

    \subsubsection{Discussão dos Resultados para Colaboração entre \emph{Threads}}

    Para analisar graficamente os dados da Tabela \ref{tab:colab} apresenta-se dois gráficos nas Figuras \ref{fig:colab_clauses} e \ref{fig:colab_tempo} que resumem as menores cláusulas geradas e o tempo gasto (em segundos) para a abordagem de colaboração entre cláusulas, respectivamente.

    \begin{figure}[!htb]
        \centering
        \caption{Gráfico das menores cláusulas geradas para abordagem de colaboração entre cláusulas}
        \includegraphics[width=13cm]{images/colab_clauses.jpg}
        \label{fig:colab_clauses}
    \end{figure}

    No gráfico da Figura \ref{fig:colab_clauses} é possível observar que as fórmulas \emph{aim-50-1\_6-no-3}, \emph{aim-50-1\_6-no-4}, \emph{dubois25} e \emph{hole7}, ao serem processadas pelo algoritmo de colaboração entre \emph{threads}, conseguiram encontrar a cláusula vazia com uma menor quantidade de cláusulas geradas a medida em que se adicionou \emph{threads} na execução.

    Com esses resultados é possível concluir que o sistema de colaboração de cláusulas, consegue reduzir significativamente o número de cláusulas geradas, entretanto é difícil estabelecer uma padrão de comportamento, pois não se sabe a ordem de execução das \emph{threads}.

    Esse método mostrou-se ineficiente se o objetivo for encontrar a cláusula vazia no menor tempo de execução possível, como pode-se observar no gráfico da Figura \ref{fig:colab_tempo}, os tempos aumentam a medida em que as \emph{threads} são inseridas, entretanto o método mostra-se eficiente se se deseja obter um menor caminho para se encontrar a cláusula vazia.

    As fórmulas \emph{aim-50-1\_6-no-1}, e \emph{hole6} não apresentaram resultado significativo no teste.

    \begin{figure}[!htb]
        \centering
        \caption{Gráfico de tempo de execução para abordagem de colaboração entre cláusulas}
        \includegraphics[width=13cm]{images/colab_tempo.jpg}
        \label{fig:colab_tempo}
    \end{figure}

    \newpage

    \subsubsection{Discussão dos Resultados para Divisão de Trabalho por \emph{Threads}}

    Os gráficos contidos nas Figuras \ref{fig:threads_clauses} e \ref{fig:threads_tempo} resumem as menores cláusulas geradas e o tempo de execução, mostrados nas Tabelas \ref{tab:threads1} e \ref{tab:threads2}.

    \begin{figure}[!htb]
        \centering
        \caption{Gráfico das menores cláusulas geradas para abordagem de divisão por \emph{threads}}
        \includegraphics[width=14cm]{images/threads_clauses.jpg}
        \label{fig:threads_clauses}
    \end{figure}

     No gráfico da Figura \ref{fig:threads_clauses}, as fórmulas \emph{aim-50-1\_6-no-1}, \emph{aim-50-1\_6-no-3} e \emph{aim-50-1\_6-no-4} apresentam considerável redução de cláusulas geradas a medida em que \emph{threads} são adicionados. As fórmulas \emph{dubois} não tiveram considerável evolução, com isso é possível concluir que as cláusulas vazias nessas fórmulas são encontradas com um mesmo número de cláusulas geradas, independente da ramificação escolhida para trabalhar.

     As fórmulas do tipo \emph{hole} apresentaram uma pequena diminuição de cláusulas geradas apenas para testes com 32 ou 64 \emph{threads}.

    \begin{figure}[!htb]
        \centering
        \caption{Gráfico de tempo de execução para abordagem de divisão por \emph{threads}}
        \includegraphics[width=14cm]{images/threads_tempo.jpg}
        \label{fig:threads_tempo}
    \end{figure}

    A Figura \ref{fig:threads_tempo} mostra um gráfico, no qual é possível perceber que se consegue uma redução considerável a medida em que se adiciona \emph{threads}, e é possível concluir ainda que, nem sempre um número elevado de threads acha a melhor solução, pois o custo para resolver várias ramificações ao mesmo tempo em um ambiente de memória compartilhada, gera concorrência na escrita em memória.

    Esse método ainda se caracteriza em dois tipos de busca, se a intenção for achar o menor caminho, um número maior de threads pode ser definido, entretanto se a intenção for encontrar o a cláusula vazia em um menor tempo não se importando com a quantidade de cláusulas geradas, então poucas \emph{threads} são suficiente.

    Para a fórmula \emph{aim-50-1\_6-no-1} o melhor desempenho em relação ao tempo foi encontrado quando o processo utilizou 2 \emph{threads}. Mas o caminho mais curto para se achar uma cláusula vazia foi encontrado apenas quando executada com 64 \emph{threads}.

    Ao se analisar um panorama geral é possível identificar outra característica interessante, a forma de construção das fórmulas influenciam diretamente no tempo necessário para encontrar uma cláusula vazia, nem sempre o número de literais ou cláusulas influencia no tempo de busca. Por exemplo, as fórmulas do tipo \emph{aim}, que têm cerca de 80 cláusulas, precisaram de um maior esforço para encontrar uma cláusula vazia, enquanto as fórmulas do tipo \emph{dubois}, especificamente a fórmula \emph{dubois100} apresenta 10 vezes mais cláusulas que as do tipo \emph{aim}, e mesmo assim são executadas em um tempo muito menor.

    A variação no desvio padrão de alguns testes se dá pela velocidade em que determinados \emph{treads} são executados, caso um \emph{thread} que leve ao resultado mais rapidamente seja executado primeiro, ou ganhe prioridade na gravação dos dados em memória, a execução do programa levará menos tempo.

    Por exemplo, na fórmula \emph{aim-50-1\_6-no-4} em média as ocorrências para a execução com 32 threads ficam na casa dos 104 segundos, entretanto em uma das ocorrências o programa consegue terminar em 52,75 segundos.

    \chapter{Conclusões}
    \label{conclusao}

    A prova por resolução é um problema que tem como característica a explosão combinatória. Resolvê-lo em um tempo viável depende de quais estratégias são adotadas. Algumas dessas estratégias foram implementadas nesse trabalho, entre elas: resolução linear, literais enquadrados, simplificação e duas abordagens de processamento paralelo.

    Na primeira abordagem buscou-se testar o quanto os \emph{threads} que estão cuidando de ramificações diferenciadas na árvore de prova podem cooperar; na segunda abordagem utilizou-se a estratégia de cada \emph{thread} cuidar de sua ramificação, não interferindo nas buscas efetuadas pelas outras.

    Apesar do processamento paralelo, o custo de sincronização na primeira abordagem e da geração de todos os filhos da árvore de prova na segunda, mostrou que a adição de \emph{threads} em geral, não aumenta o \emph{speedup} do algoritmo.

    Com a primeira abordagem consegui-se demonstrar que a colaboração entre as cláusulas consegue abreviar a busca pela cláusula vazia, já com a divisão das ramificações por \emph{threads} demonstra-se que a busca por várias ramificações da árvore é vantajosa, entretanto, buscar por ramificações que não tem cláusula vazia, congestionam o acesso a memória com dados que não são aproveitados e fazem o algoritmo demorar mais que o necessário.

    \section{Trabalhos Futuros}

    Como principal trabalho futuro, deixa-se a tentativa de junção das abordagens, conseguir o compartilhamento entre cláusulas numa abordagem completa pode gerar bons resultados de tempo.

    Ainda é possível explorar outro tipo de paralelismo, além da busca em diferentes ramificações, utilizar \emph{threads} específicos para aplicar estratégias de resolução descritas na Seção \ref{estrategias}, com isso esses \emph{threads} ficam responsáveis por diminuir o espaço de busca e remover cláusulas que não iriam servir para a resolução do problema.

    Uma outra abordagem também propõe um método relaxado, que abandona ramificações que não foram resolvidas em determinado tempo, essa abordagem aproveita melhor o paralelismo, pois como visto nos resultados, ao testar uma fórmula com vários \emph{threads}, a cláusula vazia é encontrada em um menor tempo.

    Explorar o segundo modelo em PRAM descrito na Seção \ref{ideia_geral} pode ser aplicada a estrutura CUDA que conta com vários multi-processadores. Dessa forma garante-se a busca por todas as cláusulas iniciais da fórmula.

    \bibliographystyle{abbrv}
    \bibliography{bib/bibliografia}

\end{document} 